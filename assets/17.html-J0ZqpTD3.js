import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,b as t,e as n,d as i,w as l,a as s,r as p,o as c}from"./app-BSIteuMx.js";const h="/blog_imgs/17/17_1.png",d={};function m(u,e){const a=p("RouteLink");return c(),r("div",null,[e[5]||(e[5]=t("h2",{id:"_1-背景",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#_1-背景"},[t("span",null,"1. 背景")])],-1)),t("p",null,[e[1]||(e[1]=n("在做命名实体识别的时候，模型识别错误的很大一部分原因是边界识别不好。因此如何将命名实体的边界进行重定向是进一步提升NER性能的利器。其中一种方法是可以利用词典和规则的方法进行边界重定向，如前文提到的《")),e[2]||(e[2]=t("a",{href:"https://bbruceyuan.github.io/post/2.html",target:"_blank",rel:"noopener noreferrer"},"利用前后向算法",-1)),e[3]||(e[3]=n("》，第二种方法可以用下文提到了指针网络进行边界重定向。此方法参考于《")),i(a,{to:"/post/%E6%8A%80%E6%9C%AF/17.html"},{default:l(()=>e[0]||(e[0]=[n("Don’t Eclipse Your Arts Due to Small Discrepancies: Boundary Repositioning with a Pointer Network for Aspect Extraction")])),_:1}),e[4]||(e[4]=n("》。"))]),e[6]||(e[6]=s('<h2 id="_2-ner错误类型" tabindex="-1"><a class="header-anchor" href="#_2-ner错误类型"><span>2. NER错误类型</span></a></h2><p>该方法可以处理两种错误类型，</p><ul><li>一种是<strong>模型识别的实体短了</strong>，少预测了两个字。</li><li>一种是<strong>模型识别长了</strong>，多预测了两个字。</li></ul><p>因此我们的想法就是将少预测的部分补全，将多预测的部分去除。而使用的方法就是重新训练一个指针网络识别新的实体边界。</p><blockquote><p>Ground-truth表示模型应该识别的边界。</p></blockquote><h2 id="_3-具体样例" tabindex="-1"><a class="header-anchor" href="#_3-具体样例"><span>3. 具体样例</span></a></h2><blockquote><p>他爱吃苹果派。</p></blockquote><p>目的是为了识别商品实体词：苹果派</p><h2 id="_4-实体边界重定位方法" tabindex="-1"><a class="header-anchor" href="#_4-实体边界重定位方法"><span>4. 实体边界重定位方法</span></a></h2><h3 id="步骤1-实体抽取模型的训练" tabindex="-1"><a class="header-anchor" href="#步骤1-实体抽取模型的训练"><span>步骤1：实体抽取模型的训练</span></a></h3><h4 id="_4-1-1-模型结构" tabindex="-1"><a class="header-anchor" href="#_4-1-1-模型结构"><span>4.1.1 模型结构</span></a></h4><p>训练命名实体识别（NER）模型，这里可以是任何一种模型。可以使用常见的 <code>CNN+Bi-LSTM+CRF</code> ，也可以是 <code>BERT+CRF</code> 总之，在这个步骤里面训练的模型可以是任意一个NER模型。比如<code>BERT+SoftMax</code>。</p><h4 id="_4-1-2-模型输入输出" tabindex="-1"><a class="header-anchor" href="#_4-1-2-模型输入输出"><span>4.1.2 模型输入输出</span></a></h4><p>输入是一段 sentence。输出是实体列表。比如：【苹果】。</p><h3 id="步骤2-边界重定向模型的训练" tabindex="-1"><a class="header-anchor" href="#步骤2-边界重定向模型的训练"><span>步骤2：边界重定向模型的训练</span></a></h3><p>假设第一步的模型输出了NER结果是：【苹果】</p><h4 id="_4-2-1-模型结构" tabindex="-1"><a class="header-anchor" href="#_4-2-1-模型结构"><span>4.2.1 模型结构</span></a></h4><p>BERT的双句分类模型结构。</p><p><img src="'+h+'" alt="image.png" loading="lazy"></p><h4 id="_4-2-2-模型的输入输出" tabindex="-1"><a class="header-anchor" href="#_4-2-2-模型的输入输出"><span>4.2.2 模型的输入输出</span></a></h4><p><strong>模型的输入</strong>： 回顾BERT双句分类，我们的sentence1应该改成步骤一里面的输出的实体。sentence2就是原来的输入的sentence。假设步骤一中一共输出了两个实体，那么我们就构建两个训练样本。</p><blockquote><p>预测正确和错误的实体都用于构建训练样本。</p></blockquote><p><strong>模型的输出</strong>： 对于这里，模型是对边界进行重定位，因此就是对 sentence2中的每一个字预测它start和end的概率，然后取start和end最大的中间那一部分当做最终预测的实体。</p><h4 id="_4-2-3-模型优化目标" tabindex="-1"><a class="header-anchor" href="#_4-2-3-模型优化目标"><span>4.2.3 模型优化目标</span></a></h4><p>这里使用是负log对数函数，当然使用其他的loss也是可以的。</p><h4 id="_4-2-4-细节-重点重点" tabindex="-1"><a class="header-anchor" href="#_4-2-4-细节-重点重点"><span>4.2.4 细节（重点重点）</span></a></h4><p><strong>Question</strong>：对于步骤2，最重要的就是如何构建 实体样本，也就是说在步骤二中应该如何获得sentence1，sentence1应该在那里获得。 <strong>Answer</strong>：候选实体的负样本通过步骤一的模型产生。具体做法是：生成一个字典(map)，当真实的实体当做key, value 是一个负样本列表。</p><p>每一个真实的实体都对应一个负样本列表。 <code>{&#39;true entity&#39;: [&#39;wrong entity1&#39;, &#39;wrong entiry2&#39;]}</code> 。把每一个训练的epoch中产生的wrong entity都加入到对应的true entity里面。wrong entiry应该和 true entity 有重合。</p><p>比如“苹果”和“苹果派”之间有重合，而“爱吃”和“苹果派”之间没有重合，因此“苹果”应该当做训练样例，而“爱吃”不应该当做负的训练样例。</p><p>Reposition 模型的正样例就是：<code>&lt;CLS&gt; 正确的实体 &lt;sep&gt; 要判断的sentence &lt;sep&gt;。</code></p><h3 id="步骤3-测试样例的推理预测" tabindex="-1"><a class="header-anchor" href="#步骤3-测试样例的推理预测"><span>步骤3：测试样例的推理预测</span></a></h3><p>模型训练部分已经讲完了，预测时候就只需要将要预测的句子输入到步骤一种的实体抽取模型中。然后对输出的实体构造样本，送入到步骤二中的实体边界重定向模型中。最后将每一个句子对应的实体都找出来，就完成了 <strong>通过实体边界重定向提高NER性能</strong> 。</p><h2 id="_5-reference" tabindex="-1"><a class="header-anchor" href="#_5-reference"><span>5. Reference</span></a></h2><p>[1] Don’t Eclipse Your Arts Due to Small Discrepancies: Boundary Repositioning with a Pointer Network for Aspect Extraction</p>',34))])}const f=o(d,[["render",m],["__file","17.html.vue"]]),y=JSON.parse('{"path":"/post/17.html","title":"NER上分利器：实体边界重定位","lang":"zh-CN","frontmatter":{"title":"NER上分利器：实体边界重定位","id":17,"date":"2021-02-10T20:20:20.000Z","description":"NER上分利器：实体边界重定位;Don’t Eclipse Your Arts Due to Small Discrepancies: Boundary Repositioning with a Pointer Network for Aspect Extraction","keywords":["BBruceyuan"],"tag":["NER"],"category":["序列标注"],"image":"blog_imgs/17/17_1.png","permalink":"/post/17.html","head":[["meta",{"property":"og:url","content":"https://yuanchaofa.com/post/17.html"}],["meta",{"property":"og:site_name","content":"chaofa用代码打点酱油"}],["meta",{"property":"og:title","content":"NER上分利器：实体边界重定位"}],["meta",{"property":"og:description","content":"NER上分利器：实体边界重定位;Don’t Eclipse Your Arts Due to Small Discrepancies: Boundary Repositioning with a Pointer Network for Aspect Extraction"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://yuanchaofa.com/blog_imgs/17/17_1.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-30T10:01:39.000Z"}],["meta",{"property":"article:tag","content":"NER"}],["meta",{"property":"article:published_time","content":"2021-02-10T20:20:20.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-30T10:01:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"NER上分利器：实体边界重定位\\",\\"image\\":[\\"https://yuanchaofa.com/blog_imgs/17/17_1.png\\"],\\"datePublished\\":\\"2021-02-10T20:20:20.000Z\\",\\"dateModified\\":\\"2024-09-30T10:01:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Chaofa Yuan\\",\\"url\\":\\"https://yuanchaofa.com\\"}]}"]]},"headers":[{"level":2,"title":"1. 背景","slug":"_1-背景","link":"#_1-背景","children":[]},{"level":2,"title":"2. NER错误类型","slug":"_2-ner错误类型","link":"#_2-ner错误类型","children":[]},{"level":2,"title":"3. 具体样例","slug":"_3-具体样例","link":"#_3-具体样例","children":[]},{"level":2,"title":"4. 实体边界重定位方法","slug":"_4-实体边界重定位方法","link":"#_4-实体边界重定位方法","children":[{"level":3,"title":"步骤1：实体抽取模型的训练","slug":"步骤1-实体抽取模型的训练","link":"#步骤1-实体抽取模型的训练","children":[{"level":4,"title":"4.1.1 模型结构","slug":"_4-1-1-模型结构","link":"#_4-1-1-模型结构","children":[]},{"level":4,"title":"4.1.2 模型输入输出","slug":"_4-1-2-模型输入输出","link":"#_4-1-2-模型输入输出","children":[]}]},{"level":3,"title":"步骤2：边界重定向模型的训练","slug":"步骤2-边界重定向模型的训练","link":"#步骤2-边界重定向模型的训练","children":[{"level":4,"title":"4.2.1 模型结构","slug":"_4-2-1-模型结构","link":"#_4-2-1-模型结构","children":[]},{"level":4,"title":"4.2.2 模型的输入输出","slug":"_4-2-2-模型的输入输出","link":"#_4-2-2-模型的输入输出","children":[]},{"level":4,"title":"4.2.3 模型优化目标","slug":"_4-2-3-模型优化目标","link":"#_4-2-3-模型优化目标","children":[]},{"level":4,"title":"4.2.4 细节（重点重点）","slug":"_4-2-4-细节-重点重点","link":"#_4-2-4-细节-重点重点","children":[]}]},{"level":3,"title":"步骤3：测试样例的推理预测","slug":"步骤3-测试样例的推理预测","link":"#步骤3-测试样例的推理预测","children":[]}]},{"level":2,"title":"5. Reference","slug":"_5-reference","link":"#_5-reference","children":[]}],"git":{"createdTime":1662801658000,"updatedTime":1727690499000,"contributors":[{"name":"bbruceyuan","email":"bruceyuan@123@gmail.com","commits":2},{"name":"Mr.Hope","email":"mister-hope@outlook.com","commits":1},{"name":"bbruceyuan","email":"bbruceyuan@tencent.com","commits":1},{"name":"bbruceyuan","email":"chaofa.yuan@bytedance.com","commits":1},{"name":"chaofa.yuan","email":"chaofa.yuan@bytedance.com","commits":1}]},"readingTime":{"minutes":3.65,"words":1095},"filePathRelative":"post/技术/17.NER上分利器-实体边界重定位.md","localizedDate":"2021年2月10日"}');export{f as comp,y as data};
